#!/usr/bin/env python

from collections import namedtuple
from json import dumps
from logging import basicConfig, getLogger, INFO
from xml.dom import minidom
from re import compile as recompile
from operator import itemgetter
from os import walk
from os.path import join, normpath
from sys import argv

basicConfig( format = '%(asctime)s %(levelname)s: %(funcName)s %(message)s', datefmt = '%Y-%m-%d %H:%M:%S', level = INFO )
LOGGER = getLogger( __name__ )

# READERS

def unicode_reader( type, keys, path ):
	with open( path, 'rb' ) as f: content = unicode( f.read(), errors = 'replace' )
	return content

def tm_signature_reader( type, keys, path ):
	with open( path, 'rb' ) as f: content = unicode( f.read(), errors = 'replace' )
	s = {}
	s[ 'uid' ], s[ 'info' ], s[ 'ip' ] = content.strip().split( '\t' )
	return s

# based on http://windyroad.org/dl/Open%20Source/JUnit.xsd
def cu_cases_reader( type, keys, path ):
	get_cdata = lambda elements: elements[ 0 ].childNodes[ 0 ].nodeValue
	xmldoc = minidom.parse( path )
	cases = []
	for tc in xmldoc.getElementsByTagName( 'testcase' ):
		case = {}
		case[ 'name' ] = tc.getAttribute( 'name' )
		case[ 'type' ] = 'ok'
		stdout = tc.getElementsByTagName( 'system-out' )
		case[ 'stdout' ] = get_cdata( stdout ) if stdout else None
		stderr = tc.getElementsByTagName( 'system-err' )
		case[ 'stderr' ] = get_cdata( stderr ) if stderr else None
		error = tc.getElementsByTagName( 'error' )
		if error:
			case[ 'error' ] = get_cdata( error )
			case[ 'type' ] = error[ 0 ].getAttribute( 'type' )
			case[ 'failure' ] = None
		else:
			failure = tc.getElementsByTagName( 'failure' )
			if failure:
				case[ 'failure' ] = get_cdata( failure )
				case[ 'type' ] = failure[ 0 ].getAttribute( 'type' )
				case[ 'error' ] = None
		cases.append( case )
	return cases

# PATTERN_READERS

PatternReader = namedtuple( 'PatternReader', 'type, pattern, reader' )
SIGNATURE, SOURCE, SOURCES, CASE, CASES = 'signature', 'source', 'sources', 'case', 'cases'

SEE_YOU = lambda _: [
	PatternReader( SOURCE, r'(?P<uid>.*)/latest/(?P<exercise>.*)/(?P<source>.*\.[ch])$', unicode_reader ),
	PatternReader( SIGNATURE, r'(?P<uid>.*)/SIGNATURE\.tsv', tm_signature_reader ),
	PatternReader( CASES, r'(?P<uid>.*)/latest/TEST-(?P=uid)\.(?P<exercise>.*)\.xml$', cu_cases_reader )
]

def ONE_EXERCISE_PER_FILE( extension ):
	return [
		PatternReader( SOURCE, r'(?P<uid>.*)/(?P<source>(?P<exercise>.*)\.{0})$'.format( extension ), unicode_reader )
	]

def ONE_EXERCISE_PER_DIRECTORY( extension ):
	return [
		PatternReader( SOURCE, r'(?P<uid>.*)/(?P<exercise>.*)/(?P<source>.*\.{0})$'.format( extension ), unicode_reader )
	]

# SORTER

def cu_sort( results ):
	for res in results:
		res[ 'exercises' ].sort( key = itemgetter( 'name' ) )
		for exercise in res[ 'exercises' ]:
			if exercise[ 'cases' ]:
				first = exercise[ 'cases' ].pop( 0 )
				exercise[ 'cases' ].sort( key = itemgetter( 'name' ) )
				exercise[ 'cases' ].insert( 0, first )
			exercise[ 'sources' ].sort( key = itemgetter( 'name' ) )
	results.sort( key = lambda _ : _[ 'signature' ][ 'uid' ] )
	return results

### SCANNER

def scan( basedir, pattern_reader ):

	results = {}

	def assign( type, keys, content ):
		try:
			uid = keys[ 'uid' ]
		except KeyError:
			raise RuntimeError( 'Keys must contains at least "uid"' )
		try:
			exercise = keys[ 'exercise' ]
		except KeyError:
			exercise = None
		try:
			source = keys[ 'source' ]
		except KeyError:
			source = None
		try:
			case = keys[ 'case' ]
		except KeyError:
			case = None
		if uid not in results:
			results[ uid ] = {
				'signature': { 'uid': uid, 'info': uid, 'ip': '' },
				'exercises': {}
			}
		if exercise and exercise not in results[ uid ][ 'exercises' ]:
			results[ uid ][ 'exercises' ][ exercise ] = {
				'sources': {},
				'cases': {}
			}
		if type == SIGNATURE:
			results[ uid ][ 'signature' ] = content
		elif type == SOURCE:
			results[ uid ][ 'exercises' ][ exercise ][ 'sources' ][ source ] = content
		elif type == SOURCES:
			results[ uid ][ 'exercises' ][ exercise ][ 'sources' ] = content
		elif type == CASE:
			results[ uid ][ 'exercises' ][ exercise ][ 'cases' ][ case ] = content
		elif type == CASES:
			results[ uid ][ 'exercises' ][ exercise ][ 'cases' ] = content
		else: raise RuntimeError( 'Keys must be "uid", or "uid, exericse", or "uid, exercise, source"' )

	# scan (using dicts)

	basedir = normpath( basedir )
	pattern_reader = [ PatternReader( _.type, recompile( join( basedir, _.pattern ) ), _.reader ) for _ in pattern_reader ]
	exercise_names = set()
	for root, dirs, files in walk( basedir, followlinks = True ):
		for name in files:
			path = join( root, name )
			for mp in pattern_reader:
				match = mp.pattern.match( path )
				if match:
					keys = match.groupdict()
					if 'exercise' in keys: exercise_names.add( keys[ 'exercise' ] )
					LOGGER.info( 'Match of type {0} with keys {1}'.format( mp.type, keys ) )
					value = mp.reader( mp.type, keys, path )
					assign( mp.type, keys, value )

	# fix (transforming dicts in lists)

	raw_results, results = results, []
	for uid, res in raw_results.items():
		exercises = []
		for exercise_name in exercise_names:
			try:
				exercise = res[ 'exercises' ][ exercise_name ]
			except KeyError:
				exercise = { 'name': exercise_name, 'sources': [], 'cases': [] }
			exercise[ 'name' ] = exercise_name
			if isinstance( exercise[ 'sources' ], dict ):
				sources = []
				for source_name, source in exercise[ 'sources' ].items():
					sources.append( { 'name': source_name, 'content': source } )
				exercise[ 'sources' ] = sources
			if isinstance( exercise[ 'sources' ], dict ):
				cases = []
				for case_name, case in exercise[ 'cases' ].items():
					case[ 'name' ] = case_name
					cases.append( case )
				exercise[ 'cases' ] = cases
			exercises.append( exercise )
		res[ 'exercises' ] = exercises
		results.append( res )

	return results

if __name__ == '__main__':
	mode, basename, ext = argv[ 1 ], argv[ 2 ], argv[ 3 ] if len( argv ) == 4 else None
	pattern_reader, sort = {
		'cu': ( SEE_YOU, cu_sort ),
		'1f': ( ONE_EXERCISE_PER_FILE, None ),
		'1d': ( ONE_EXERCISE_PER_DIRECTORY, None )
	}[ mode ]
	result = scan( basename, pattern_reader( ext ) )
	if sort: result = sort( result )
	print dumps( result )
