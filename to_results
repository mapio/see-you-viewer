#!/usr/bin/env python

from json import dumps
from logging import basicConfig, getLogger, INFO
from xml.dom import minidom
from re import compile as recompile
from operator import itemgetter
from os import walk
from os.path import join, normpath
from sys import argv, stderr

basicConfig( format = '%(asctime)s %(levelname)s: %(funcName)s %(message)s', datefmt = '%Y-%m-%d %H:%M:%S', level = INFO )
LOGGER = getLogger( __name__ )

class FileSystemConverter( object ):

	def __init__( self, basedir = '.', **patterns ):
		_adjust = lambda _: recompile( join( self.basedir, patterns[ _ ] ) ) if _ in patterns else None
		self.basedir = normpath( basedir )
		self.signature_pattern = _adjust( 'signature' )
		self.source_pattern = _adjust( 'source' )
		self.cases_pattern = _adjust( 'cases' )

	def signature( self, path, match ):
		return match[ 'uid' ], match[ 'uid' ], ''

	def _signature( self, path ):
		if not self.signature_pattern: return None
		match = self.signature_pattern.match( path )
		if match:
			match = match.groupdict()
			LOGGER.info( 'match {0}'.format( match ) )
			return match[ 'uid' ], self.signature( path, match )
		return None

	def source( self, path, match ):
		with open( path, 'rb' ) as f: content = unicode( f.read(), errors = 'replace' )
		return content

	def _source( self, path ):
		if not self.source_pattern: return
		match = self.source_pattern.match( path )
		if match:
			match = match.groupdict()
			LOGGER.info( ' match {0}'.format( match ) )
			return match[ 'uid' ], match[ 'exercise' ], match[ 'source' ], self.source( path, match )
		return None

	def cases( self, path, match ):
		return []

	def _cases( self, path ):
		if not self.cases_pattern: return None
		match = self.cases_pattern.match( path )
		if match:
			match = match.groupdict()
			LOGGER.info( 'match {0}'.format( match ) )
			return match[ 'uid' ], match[ 'exercise' ], self.cases( path, match )
		return None

	def scan( self ):
		exercise_names = set()
		results = {}
		def _ensure_result( uid, exercise = None ):
			if not uid in results:
				results[ uid ] = {
					'uid': uid,
					'info': uid,
					'ip': '',
					'exercises': {}
				}
			if exercise and not exercise in results[ uid ][ 'exercises' ]:
				results[ uid ][ 'exercises' ][ exercise ] = {
					'sources': {},
					'cases': []
				}
		for root, dirs, files in walk( self.basedir, followlinks = True ):
			for name in files:
				path = join( root, name )
				signature = self._signature( path )
				if signature:
					uid, signature = signature
					_ensure_result( uid )
					( results[ uid ][ 'uid' ],
					  results[ uid ][ 'info' ],
					  results[ uid ][ 'ip' ] ) = signature
					continue
				source = self._source( path )
				if source:
					uid, exercise, source, content = source
					exercise_names.add( exercise )
					_ensure_result( uid, exercise )
					results[ uid ][ 'exercises' ][ exercise ][ 'sources' ][ source ] = content
					continue
				cases = self._cases( path )
				if cases:
					uid, exercise, cases = cases
					_ensure_result( uid, exercise )
					results[ uid ][ 'exercises' ][ exercise ][ 'cases' ] = cases
		self.results = []
		for uid, res in results.items():
			exercises = []
			for exercise_name in exercise_names:
				try:
					exercise = res[ 'exercises' ][ exercise_name ]
				except KeyError:
					exercise = { 'name': exercise_name, 'sources': {}, 'cases': [] }
				exercise[ 'name' ] = exercise_name
				sources = []
				for source_name, source in exercise[ 'sources' ].items():
					sources.append( { 'name': source_name, 'content': source } )
				exercise[ 'sources' ] = sources
				exercises.append( exercise )
			res[ 'exercises' ] = exercises
			self.results.append( res )
		self.exercise_names = exercise_names
		return self

	def sort( self ):
		return self

	def tojson( self ):
		return dumps( self.results )

class SeeYouConverter( FileSystemConverter ):

	def __init__( self, basedir ):
		super( SeeYouConverter, self ).__init__( basedir,
			source = r'(?P<uid>.*)/latest/(?P<exercise>.*)/(?P<source>.*\.[ch])$',
			signature = r'(?P<uid>.*)/SIGNATURE\.tsv',
			cases = r'(?P<uid>.*)/latest/TEST-(?P=uid)\.(?P<exercise>.*)\.xml$',
		)

	def signature( self, path, match ):
		with open( path, 'rb' ) as f: signature = unicode( f.read(), errors = 'replace' ).strip().split( '\t' )
		return signature

	# based on http://windyroad.org/dl/Open%20Source/JUnit.xsd
	def cases( self, path, match ):
		get_cdata = lambda elements: elements[ 0 ].childNodes[ 0 ].nodeValue
		xmldoc = minidom.parse( path )
		cases = []
		for tc in xmldoc.getElementsByTagName( 'testcase' ):
			case = {}
			case[ 'name' ] = tc.getAttribute( 'name' )
			case[ 'type' ] = 'ok'
			stdout = tc.getElementsByTagName( 'system-out' )
			case[ 'stdout' ] = get_cdata( stdout ) if stdout else None
			stderr = tc.getElementsByTagName( 'system-err' )
			case[ 'stderr' ] = get_cdata( stderr ) if stderr else None
			error = tc.getElementsByTagName( 'error' )
			if error:
				case[ 'error' ] = get_cdata( error )
				case[ 'type' ] = error[ 0 ].getAttribute( 'type' )
				case[ 'failure' ] = None
			else:
				failure = tc.getElementsByTagName( 'failure' )
				if failure:
					case[ 'failure' ] = get_cdata( failure )
					case[ 'type' ] = failure[ 0 ].getAttribute( 'type' )
					case[ 'error' ] = None
			cases.append( case )
		return cases

	def sort( self ):
		for res in self.results:
			res[ 'exercises' ].sort( key = itemgetter( 'name' ) )
			for exercise in res[ 'exercises' ]:
				if exercise[ 'cases' ]:
					first = exercise[ 'cases' ].pop( 0 )
					exercise[ 'cases' ].sort( key = itemgetter( 'name' ) )
					exercise[ 'cases' ].insert( 0, first )
				exercise[ 'sources' ].sort( key = itemgetter( 'name' ) )
		self.results.sort( key = itemgetter( 'uid' ) )
		return self

class OneFilePerExercise( FileSystemConverter ):

	def __init__( self, basedir, extension = '.*' ):
		super( OneFilePerExercise, self ).__init__( basedir,
			source = r'(?P<uid>.*)/(?P<source>(?P<exercise>.*)\.{0})$'.format( extension )
		)


if __name__ == '__main__':
	print SeeYouConverter( argv[ 1 ] ).scan().sort().tojson()
	#print OneFilePerExercise( argv[ 1 ], 'java' ).scan().sort().tojson()
